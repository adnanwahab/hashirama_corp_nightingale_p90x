package main

import (
	"fmt"
)

package main

import (
		"html/template"
	//"net/http"
	"io"
	// 	"bufio"
	// "encoding/base64"
	//
	// "encoding/json"
	// "errors"
	// "fmt"
	// "io"
	// "os"
	// "strings"
	"os"
	"os/exec"
	"path/filepath"
	"sync"

	// "github.com/pion/interceptor"
	// "github.com/pion/interceptor/pkg/intervalpli"
	// "github.com/pion/webrtc/v4"
	"fmt"
	//	"log"
	"github.com/labstack/echo/v4"
	//"github.com/labstack/echo/v4/middleware"
	//"github.com/playwright-community/playwright-go"
	//"net/http"
	"bytes"
	// "embed"
	// "log"

)


type Template struct {
    templates *template.Template
}


func (t *Template) Render (w io.Writer, name string, data interface {}, c echo.Context) error {
	return t.templates.ExecuteTemplate(w, name, data)
}


var assets []byte

//https://tailscale.com/blog/remote-gpus-docker-wsl2-immich
// https://www.youtube.com/watch?v=StZJtDpNvT0
// https://www.youtube.com/watch?v=HP8U02ZdnkY&t=967s
// https://www.youtube.com/watch?v=zjkBMFhNj_g
// https://www.youtube.com/watch?v=eUuGdh3nBGo
//
// https://github.com/nicholasserra/reddit-simple-media-scrape/blob/master/reddit_scrape.py


func runScript(scriptPath string, wg *sync.WaitGroup) (error, *exec.Cmd) {
	//defer wg.Done()

	cmd := exec.Command("bash", scriptPath)
	cmd.Dir = filepath.Dir(scriptPath)


	var outBuf, errBuf bytes.Buffer
	cmd.Stdout = &outBuf
	cmd.Stderr = &errBuf

	err := cmd.Start()
	if err != nil {
		fmt.Printf("Error starting script %s: %s\n", scriptPath, err)
		return err, cmd
	}

	fmt.Printf("Running script: %s\n", scriptPath)
	//https://github.com/panjf2000/gnet



	//
	///	https://github.com/VividCortex/godaemon/





	//home/adnan/hashirama/services"


	//











	err = cmd.Wait()
	if err != nil {
		fmt.Printf("Error executing script %s: %s\n", scriptPath, err)
	}

	fmt.Printf("Output: %s\n", outBuf.String())

    fmt.Printf("Error: %s\n", errBuf.String())
	return err, cmd
}

//https://tutorialedge.net/paths/golang/
//
func myass (  ) {
	basePath := os.ExpandEnv("$HOME/hashirama/services")
	var wg sync.WaitGroup
	err := filepath.Walk(basePath, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() && info.Name() != "services" {
			scriptPath := filepath.Join(path, "start.sh")
			if _, err := os.Stat(scriptPath); err == nil {
				wg.Add(1)
				err, cmd := runScript(scriptPath, &wg)
				if err != nil {
					fmt.Printf("Script failed: %s\n", err)
					return err
				} else {
					fmt.Printf("Script executed successfully: %s\n", cmd)
				}
			}
		}
		return nil
	})
	//wg.Wait() // Wait for all goroutines to finish
	if err != nil {
		fmt.Printf("shti", err)

		return
	}
}
func main() {
	getNumber()
	e := echo.New()
	//e.SetDebug(true)
	//parse()
	//e.Use(middleware.Logger())
	//e.Use(middleware.Recover())
	//
	//
	//myass()

	hello := func (c echo.Context) error {
		fmt.Printf("received route on / ")
		filePath := os.ExpandEnv("$HOME/hashirama/services/homelab-status-page/views/*.html")
		tmpl, err := template.ParseFiles(filePath)
		if err != nil {
			fmt.Printf("error we are fucked")
			return err
		}

		tmpl.Execute(c.Response().Writer, nil)
		return nil
	//return c.String(http.StatusOK, "Hello, World!")
}
	e.GET("/", hello)

	e.Logger.Fatal(e.Start(":1000"))

}

// Handler


//https://github.com/ddosify/ddosify
	//https://github.com/appleboy/easyssh-proxy
	// https://github.com/paypal/gatt
	// https://github.com/hybridgroup/gobot/
	// protoo l buffer
	// https://github.com/jaypipes/ghw
	// https://github.com/go-vgo/robotgo
	// https://github.com/aler9/goroslib
	// https://github.com/ekkinox/yai
	// https://github.com/SpatiumPortae/portalx
	// https://github.com/Antonito/gfile

//https://www.youtube.com/watch?v=x7v6SNIgJpE
// https://pkg.go.dev/embed
// https://github.com/rakyll/statik
// https://www.consul.io/
// https://github.com/topfreegames/apm
// https://github.com/jutkko/copy-pasta
//https://github.com/msempere/golarm
//
// https://github.com/mehanizm/airtable
// https://github.com/ChimeraCoder/anaconda
// https://github.com/aws/aws-sdk-go-v2
// https://github.com/nstratos/go-myanimelist
// https://github.com/sashabaranov/go-openai
// https://gitlab.com/toby3d/telegraph

//https://github.com/andygrunwald/go-trending
//https://github.com/FreeLeh/GoFreeDB
// https://github.com/GoogleCloudPlatform/gcloud-golang
// https://github.com/n0madic/google-play-scraper
// https://github.com/rapito/go-shopify
//
// https://github.com/slack-go/slack
// https://github.com/sostronk/go-steam
// https://github.com/stripe/stripe-go
// https://github.com/n0madic/twitter-scraper
// https://github.com/topfreegames/apm
//
//
// gmf - Go bindings for FFmpeg av* libraries.

// go-astiav - Better C bindings for ffmpeg in GO.
// go-astisub - Manipulate subtitles in GO (.srt, .stl, .ttml, .webvtt, .ssa/.ass, teletext, .smi, etc.).
// go-astits - Parse and demux MPEG Transport Streams (.ts) natively in GO.
// go-m3u8 - Parser and generator library for Apple m3u8 playlists. Actively maintained version of quangngotan95/go-m3u8 with improvements and latest HLS playlist parsing compatibility.
// go-mpd - Parser and generator library for MPEG-DASH manifest files.
// goav - Comprehensive Go bindings for FFmpeg.
// gortsplib - Pure Go RTSP server and client library.
// gst - Go bindings for GStreamer.
// libgosubs - Subtitle format support for go. Supports .srt, .ttml, and .ass.
// libvlc-go - Go bindings for libvlc 2.X/3.X/4.X (used by the VLC media player).
// m3u8 - Parser and generator library of M3U8 playlists for Apple HLS.
// v4l - Video capture library for Linux, written in Go.
//https://github.com/odeke-em/drive
//https://github.com/crufter/borg
// https://github.com/theia-ide/go-language-server
// https://github.com/andygrunwald/go-trending
